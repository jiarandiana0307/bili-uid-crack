from .uid_range import UidRange


# 16位UID第一个分布区间的起点
UID16_START = 3461562_035_603_456
# 16位UID相邻分布区间起点的距离（步长）
UID16_STEP = 2 ** 21
# 16位UID每个分布区间的长度，即每个区间包含的UID数量
UID16_INTERVAL_LEN = 1000

# 由于16位UID分布规律的特殊性，对16位UID进行破解需要生成UID字典文件进行破解。
# 这个常量指定每次生成UID字典文件时允许使用的最大区间数量，用于控制生成的临时
# 字典文件的大小及破解速度。
#
# 字典文件大小：最大区间数量乘以每个区间的UID数量1000就是字典文件中UID的数量，
# 由于每行UID包含UID的16个字符再加上一个换行符，所以每行UID占用17字节，UID数量
# 乘以17就得到了字典文件占用存储空间大小。如果存储空间或内存有限可以调小一点，
# 如果足够则可调大。
#
# 破解性能：由于hashcat的每次启停都需要较长的时间（约几秒钟），所以，只要每次生成的
# 字典文件中UID的数量越多，hashcat每次处理的UID数量就越多，hashcat总的启停次数就少，
# 破解速度就越快，当然，生成字典文件时所占用的存储空间和内存也越多。John the Ripper
# 的启停速度快，破解性能几乎不受字典大小及此参数的影响。
UID16_MAX_INTERVAL_NUM = 20000

# 根据不同UID号段的启用时间以及UID十进制位数划分的UID分布范围。
# UID启用时间的信息来自于：https://tieba.baidu.com/p/9401456992
# UID数据来源于aicu.cc：https://t.me/aicu_cc
UID_20090624_20201029   = UidRange(1, 703_223_216)
UID_LESS_THEN_10_DIGITS = UID_20090624_20201029
UID_10_DIGITS           = UidRange(1_000_000_000, 3_000_000_000-1)
UID_20220428_20221029   = UidRange(3461562_035_603_456, 3461583_361_543_144)
UID_20221029            = UidRange(3492972_683_331_584, 3492972_897_242_088)
UID_20221029_20230304   = UidRange(3493074_414_077_952, 3493146_749_045_736)
UID_20230304_20230521   = UidRange(3493256_331_528_192, 3493299_291_687_912)
UID_20230521_20230718   = UidRange(3494349_157_435_392, 3494381_315_165_160)
UID_20230718            = UidRange(3536993_493_452_800, 3536997_689_854_952)
UID_20230718_20230820   = UidRange(3537104_332_130_304, 3537125_809_064_936)
UID_20230820_20230929   = UidRange(3546366_282_303_488, 3546394_491_096_040)
UID_20230929_Now        = UidRange(3546554_061_293_568, 3547000_000_000_000)

# 16位UID的分布范围。
UID_RANGES_16_DIGITS    = [
    UID_20220428_20221029, UID_20221029, 
    UID_20221029_20230304, UID_20230304_20230521, 
    UID_20230521_20230718, UID_20230718, 
    UID_20230718_20230820, UID_20230820_20230929, 
    UID_20230929_Now
]

# 所有可能的UID的分布范围。
UID_RANGES_ALL = [
    UID_LESS_THEN_10_DIGITS, UID_10_DIGITS, *UID_RANGES_16_DIGITS
]